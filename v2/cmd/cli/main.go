package main

import (
	"context"
	"fmt"
	"io"
	"log"
	"os"

	pb "github.com/hongkongkiwi/go-currency-nodes/v2/gen/pb"
	"github.com/tebeka/atexit"
	"github.com/urfave/cli/v2"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"

	cliCmds "github.com/hongkongkiwi/go-currency-nodes/v2/internal/cli_cmds"
	"github.com/hongkongkiwi/go-currency-nodes/v2/internal/configs"
	"github.com/hongkongkiwi/go-currency-nodes/v2/internal/helpers"
)

func connectController(controller string) error {
	if configs.CliCfg.VerboseLog {
		log.Printf("config controller addr: %s", configs.CliCfg.ControllerServer)
	}
	conn, err := grpc.Dial(
		controller,
		grpc.WithTransportCredentials(insecure.NewCredentials()),
	)
	if err != nil {
		return fmt.Errorf("ERROR can not connect with controller %v", err)
	}

	// create stream
	client := pb.NewCliCmdStreamClient(conn)
	stream, err := client.CliCommandStream(context.Background())
	if err != nil {
		return fmt.Errorf("ERROR openn stream error %v", err)
	}

	ctx := stream.Context()

	log.Printf("Connected to Controller %s", controller)

	// Thread for sending hello command
	go func() {
		for {
			select {
			case <-cliCmds.CancelChan:
				return
			case command := <-cliCmds.SendChan:
				if err := stream.Send(command); err != nil {
					log.Printf("can not send %v", err)
					cliCmds.CancelChan <- true
				}
				log.Printf("command sent: %v", command)
			}
		}
		// if err := stream.CloseSend(); err != nil {
		// 	log.Println(err)
		// }
	}()

	// Thread for reciving commands
	// if stream is finished it closes done channel
	go func() {
		for {
			in, err := stream.Recv()
			if err == io.EOF {
				if cliCmds.CancelChan != nil {
					cliCmds.CancelChan <- true
					close(cliCmds.CancelChan)
				}
				return
			}
			if err != nil {
				log.Printf("can not receive %v", err)
				cliCmds.CancelChan <- true
				return
			}
			cliCmds.HandleIncomingReply(in)
		}
	}()

	// third goroutine closes done channel
	// if context is done
	go func() {
		<-ctx.Done()
		if err := ctx.Err(); err != nil {
			log.Println(err)
		}
		if cliCmds.CancelChan != nil {
			cliCmds.CancelChan <- true
			close(cliCmds.CancelChan)
		}
	}()

	<-cliCmds.CancelChan
	return nil
}

func cliVersion() error {
	fmt.Println("cli version:", configs.CliAppVersion)
	return nil
}

func handleArgs(cCtx *cli.Context) error {
	var err error
	configs.CliCfg, err = configs.NewCliCfgFromArgs(cCtx)
	if err != nil {
		return err
	}
	if configs.CliCfg.VerboseLog {
		log.Printf("config cli uuid: %s", configs.CliCfg.UUID().String())
	}
	return nil
}

func main() {
	app := &cli.App{
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:    configs.ArgCliFlagCliUuid,
				EnvVars: configs.ArgEnvCliUuid[:],
				Usage:   "uuid of this cli client (autogenerated if not passed)",
			},
			&cli.StringFlag{
				Name:    configs.ArgCliFlagController,
				Value:   configs.DefaultCliConnectController,
				EnvVars: configs.ArgEnvCliControllers[:],
				Usage:   "controller address to connect to",
			},
			&cli.BoolFlag{
				Name:    configs.ArgCliFlagVerbose,
				Value:   false,
				EnvVars: configs.ArgEnvCliVerbose[:],
				Usage:   "turn on verbose logging",
			},
		},
		Commands: []*cli.Command{
			{
				Name:    "version",
				Aliases: []string{"v"},
				Usage:   "display cli app version",
				Action: func(cCtx *cli.Context) error {
					return cliVersion()
				},
			},
			{
				Name:    "controller",
				Aliases: []string{"n"},
				Usage:   "options for controller control",
				Subcommands: []*cli.Command{
					{
						Name:    "nodes",
						Aliases: []string{"s"},
						Usage:   "show all nodes connected",
						Action: func(cCtx *cli.Context) error {
							if err := handleArgs(cCtx); err != nil {
								return err
							}
							cliCmds.SendChan = make(chan *pb.StreamFromCli)
							cliCmds.CancelChan = make(chan bool)
							// Queue up our command
							go cliCmds.ControllerListNodesV1Req()
							// Attempt to connect
							connectController(configs.CliCfg.ControllerServer)
							return nil
						},
					},
				},
			},
			{
				Name:    "node",
				Aliases: []string{"n"},
				Usage:   "options for node control",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:     configs.ArgCliFlagNodeUuids,
						Required: true,
						EnvVars:  configs.ArgEnvCliNodeUuids[:],
						Usage:    "one or more uuids to send command to",
					},
				},
				Subcommands: []*cli.Command{
					{
						Name:    "status",
						Aliases: []string{"s"},
						Usage:   "show the node status",
						Action: func(cCtx *cli.Context) error {
							if err := handleArgs(cCtx); err != nil {
								return err
							}
							nodeUuidsArg := cCtx.StringSlice("node-uuid")
							ndoeUuids, errors := helpers.UuidsFromStrings(nodeUuidsArg)
							if len(errors) > 0 {
								return fmt.Errorf("errors with the passed node UUIDs %v", errors)
							}
							cliCmds.SendChan = make(chan *pb.StreamFromCli)
							// Queue up our command
							go cliCmds.NodeStatusV1Req(ndoeUuids)
							// Attempt to connect
							connectController(configs.CliCfg.ControllerServer)
							return nil
						},
					},
				},
			},
		},
	}

	if err := app.Run(os.Args); err != nil {
		atexit.Fatalf("ERROR: %v", err)
	}
}
